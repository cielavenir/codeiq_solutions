#!/usr/bin/ruby
#coding:utf-8

S=DATA.gets.chomp
PAYLOAD=DATA.gets.chomp

#puts S
a=S.bytes
$><<'.' # null byte (デスマコロシアム細則)
if true
	$><<'-'+PAYLOAD+'-'*(256-a[0]-1)+'.'
	a.each_cons(2){|x,y|$><<'-'*((256-y+x)%256)+'.'}
else
	$><<'+'+PAYLOAD+'+'*(a[0]-1)+'.'
	a.each_cons(2){|x,y|$><<'+'*((y-x+256)%256)+'.'}
end

=begin
Baleineとはスカイガンナーの空中戦艦の1つ.ただしガンナーマシンではない.
Courageと書いてかれっじではなくくらーじゅと読ませるのも厳しいかと存じます.

それはさておき。
まず、「文字種Cについて、相手が使う前に自分が使い、それ以降のコードがCだけで構成されている」ことが自分のコードの全文字種で真
( all(my_code.index(c)<(opponent_code.index(c) if c in opponent_code else INF) for c in set(my_code)) )
ならば、相手が使っていれば勝利、使っていなければ引き分けが確定する、という重要な事実に気づく必要がある。
また、レギュレーションから判断しデスマコロシアム細則を応用できる(ヌルバイトが入っていても見た目があっていれば良い)と判断。
これらから、
.-PAYLOAD
でコードを開始して、PAYLOADより後を.と-のみのコードで記述するのが最善だと判断した。
前述の理由で、後半に置く文字種は少ないほど効果が高いので、(byte)0〜255をデクリメントすることで目的の文字コードを得る実装。
ただしPAYLOADが長すぎると後側が倒されやすくなる欠点はあるため、慎重に記述する必要は残る。

普通のBF以外にはまず負けないコードなので、とりあえず、最強かと。
しかも、わざと無駄コード(「+0;」など)を先頭に入れる場合でも、(入れるとしてもインクリメントの+であり)-で入れる人はまずいないであろう。
他のBF上位についても、1文字目が.になっている答案はまずないだろうから、勝てる見込みは高い。

[150906] なぜか負けが6個も。とりあえずhwbattle2のコードを読んで研究。
[150909] 負け数が増えてしまったので一部戻す。でもPHPとPerlの処理は残す。
[150916]
思い直し、ほぼ初版に戻した。ただし、前半と後半を入れ替え、「0p」は「,」に変更。
エスケープ攻撃はバックスラッシュのみが担当し、高級言語の文字列生成にはカンマかバックスラッシュを必ず要するとした。
あと、256文字長いシーケンスが生成されることのあったバグを修正。

=:PHP
q:Perl
%:Ruby
(:関数
0:8進数
^:xor
":文字列
 :文字列中に出現・セパレータ
\:エスケープ
;:区切り
,:文字列中に出現・引数

=end
__END__
preemptive "hello, world"
"\;,

以下、提出履歴
[1] 0p"\;
[2] =q%(0^" \;
[3] =qp"\