#!/usr/bin/ruby
N=gets.to_i
p (1..N).min_by{|i|
	#まず、期待値sは次のように求められる。
	#e=Rational((i..N).reduce(:+),N-i+1)
	e=Rational(i+N,2)
	x=Rational(N-i+1,N)
	#s=100.times.reduce(0){|s,j|s+(e-j)*(x)*(1-x)**j}

	#このsを、和を用いない形に変形する。
	###       s[i] = ex + (e-1)x(x') + ... + (e-i)x(x')^i
	###     x's[i] =          ex(x') + ... +              + (e-i)x(x')^(i+1)
	### (1-x')s[i] = ex -      x(x') - ... -      x(x')^i - (e-i)x(x')^(i+1)
	#s=(e*x-(1..100).reduce(0){|s,i|s+x*(1-x)**i}-(e-100)*x*(1-x)**101)/(1-(1-x))

	#この「100」は「ある程度大きな数」なので、右の項は極限を取ることにより消去することができる。
	#同様に、中央の項も無限級数にする。こちらは上と違って等比級数なので求めるのは容易である。
	#s=(e*x-(1..100).reduce(0){|s,i|s+x*(1-x)**i})/x
	#s=(e*x-x*(1-x)/(1-(1-x)))/x
	#s=(e*x-x*(1-x)/x)/x
	s=e+1-1/x
	#無限級数の形にすることで、有理数に持ち込めるので、min_byによる比較が誤差なく可能となる。
	#[-s,i]
	#min_byの仕様により、iはキーとして不要である。
	-s
}

__END__
上の計算を短く書くと次のようになる。
p (1..N=gets.to_i).min_by{|i|[Rational(N,N-i+1)-Rational(i+N+2,2),i]}
さらに、比較に用いるだけなら正確な期待値は必要でないので、
不必要な部分をできるだけ削ると次のようになり、Ruby(50)が完成する。
p (1..N=gets.to_i).max_by{|i|i+Rational(2*N,~N+i)}
なお、本設問では誤差が許容されることを利用すると、44バイトになる。
p (1..N=gets.to_i).max_by{|i|i+2.0*N/(~N+i)}
なお、i+2N/(i-N-1)を微分すると、1-2N/(i-N-1)**2となる。これが0になるのは、i=N+1-sqrt(2N)のときである。
しかし、左側と右側の差があるので、この値を直接使うのは難しい。
ただし、今回、入力が1<N<30なので、適当な値を足すことで通すことができたりする。
p (1.4-(2*N=gets.to_i)**0.5+N).to_i
(とりあえず2<=N<=60で全部正しい答えを返すので良しとしましょう^^;でもこういうコーディングを業務でしちゃだめ)