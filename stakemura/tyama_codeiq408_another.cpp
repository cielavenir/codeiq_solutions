#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <cstdlib>
using namespace std;
vector<string>v={ //C++11 only
	"alignas",
	"alignof",
	"and",
	"and_eq",
	"asm",
	"auto",
	"bitand",
	"bitor",
	"bool",
	"break",
	"case",
	"catch",
	"char",
	"char16_t",
	"char32_t",
	//"class",
	"compl",
	"const",
	"constexpr",
	"const_cast",
	"continue",
	"decltype",
	"default",
	"delete",
	"do",
	"double",
	"dynamic_cast",
	//"else",
	//"enum",
	//"explicit",
	//"export",
	"extern",
	"false",
	"float",
	"for",
	"friend",
	"goto",
	"if",
	"inline",
	"int",
	"long",
	//"mutable",
	"namespace",
	"new",
	"noexcept",
	"not",
	"not_eq",
	"nullptr",
	"operator",
	"or",
	"or_eq",
	"private",
	"protected",
	"public",
	//"register",
	"reinterpret_cast",
	"return",
	"short",
	"signed",
	"sizeof",
	//"static",
	"static_assert",
	"static_cast",
	"struct",
	"switch",
	"template",
	"this",
	"thread_local",
	//"throw",
	//"true",
	"try",
	"typedef",
	"typeid",
	//"typename",
	"union",
	"unsigned",
	"using",
	"virtual",
	"void",
	"volatile",
	//"wchar_t",
	"while",
	"xor",
	"xor_eq",
};
unordered_map<string,vector<string> >m;
vector<string> lst_max;
int i_max=0;
void dfs(vector<string>&lst,unordered_map<string,int> &visit,string &cur) throw(int){
	vector<string>&v=m[cur];
	int i=0,j;
	for(;i<v.size();i++){
		if(!visit[v[i]]){
			lst.push_back(v[i]);
			visit[v[i]]=visit[cur]+1;
			dfs(lst,visit,v[i]);
			visit[v[i]]=0;
			lst.pop_back();
		}
	}
	if(lst.size()>i_max){
		//cout<<lst.size()<<endl;
		i_max=lst.size(),lst_max=lst;
	}
	//if(i_max>=36-12)throw 0; //never thrown :p
}
int main(int argc, char **argv){
	int i,j;
/*
	string s;
	for(;getline(cin,s);){
		if(s[s.size()-1]=='\r')s=s.substr(0,s.size()-1);
		v.push_back(s);
	}
*/
	for(i=0;i<v.size();i++)for(j=0;j<v.size();j++){
		if(v[i][v[i].size()-1]==v[j][0]){
			//m[v[i]].push_back(v[j]);
			m[v[j]].push_back(v[i]);
		}
	}
	try{
		string start="try";
		vector<string>lst;
		lst.push_back(start);
		unordered_map<string,int>visit;
		visit[start]=1;
		dfs(lst,visit,start);
	}catch(int){}
	reverse(lst_max.begin(),lst_max.end());
	//cout<<lst_max.size()<<endl;
	for(i=0;i<lst_max.size();i++)cout<<lst_max[i]<<endl;
}
/*
C++11を使用した。
まず、リストからregister/else/class-static/enum-mutable/explicit-true/export-typename/throw-wchar_tを取り除いた。
この状態でtryを始点にした逆方向探索において23個のしりとりを検出することができた(全探索で約4秒)。
alignas
signed
do
or
reinterpret_cast
thread_local
long
goto
operator
return
not
template
extern
noexcept
typedef
float
typeid
dynamic_cast
this
sizeof
friend
default
try
よって解答は35連鎖であり、その１つの例は次のようになる。
alignas
static
class
signed
do
or
register
reinterpret_cast
thread_local
long
goto
operator
return
not
template
extern
noexcept
typedef
float
typeid
dynamic_cast
this
sizeof
friend
default
true
else
enum
mutable
export
throw
wchar_t
typename
explicit
try
(編注：嘘解法です。static_cast-thisを潰すと35連鎖できなくなります)
*/