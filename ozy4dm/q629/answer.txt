●使用言語（必須）
C++ (clang++ -O3)
反復処理部分はRuby

●アルゴリズムの説明（必須）
[1]動的計画法1
最大容積分の、価値を保存する1次元配列と最後に保存した品物を保存する1次元配列を用意
価値の配列の先頭は番兵1を立てる(その代わり結果として出力される価値から1を引く)
同じ品物は最大1個と決まっているので、後ろから舐める
これにより最大価値は55981684で、所要容積は37317001とわかった。
しかしながら、バックトラックがうまく行かず、どういうわけか同じ品物を何度も拾っているようである。

[2]貪欲法(greedy.txt)
単位価値が大きい順番に並べることで、探索開始から数秒で55981679の解を出すことが可能である。

[3]動的計画法2(problem.out.txt)
おそらく55981679点でも上級は取れるのだが、神級がほしいため、55981684点を取ることを決意した。
バックトラックがうまくいかない場合、バックトラック用の配列を2次元にすれば回避可能である。
しかし、shortを使ったとしても、74.6*10000=746000MB、すなわち746GBものメモリを必要としてしまう。
大学のスパコンには2TBを有するマシンが存在するが、例え10分でもそのうち1/3を専有するプロセスを実行するのは非常に危険である。
そこで、メモリの代わりに時間の上にバックトラック情報を乗せることにした。
「最大価値は55981684で、所要容積は37317001」ということはわかっているため、37317001にぴったり収まる方法を探した。
最後に価値を更新したのは9997番目(0-indexed)の品物で、その重量は5953である。
そこで、9997個の品物で37311048にぴったり収まる方法を探した。
最後に価値を更新したのは9995番目(0-indexed)の品物で、その重量は5904である。
そこで、9995個の品物で37305144にぴったり収まる方法を探した。
以上を容積が0になるまで反復することで解を出すことが可能である。

●苦労した点やアピールポイント等があれば
MacBookAir Core i7 (3GHz on TurboBoost)で8日間を計算に要しました。
反復の様子はprogress.txtに記してあります。
# ようやく10.9.1アップデートの再起動が掛けられます--;
ただ、品物を1000個使うたびに、途中経過をファイルに出力しておき、次回はそのファイルを読み出すようにしておけば少しは早く終われたかもしれないですね。
●その他、問題についてのご感想・ご提案・ご質問があれば
今回は問題の入力が1個しかなく、点数により級がわかれる形式であったために、かなりゴリ押しでしたが解答することが出来ました。
解説楽しみにしておりますね…。

-----
ご提出の際には、
・problem.out.txt
・answer.txt
・ソースコード等（任意）
をzip圧縮したものをご提出ください。

※問題の内容に関するご質問・不備等のご指摘に関しましては、twitterアカウント@ozy4dmにメッセージをお送りいただくか、ozy4dm@gmail.comまで電子メールにてお知らせください。
