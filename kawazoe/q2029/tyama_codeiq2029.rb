#!/usr/bin/ruby
while s=gets
	n=s.to_i
	break if n==0
	r=0
	(2..1/0.0).each{|i|
		x=n-i*(i-1)/2
		break if x<i ### x<=0
		#if x%i==0
		if n%i==[i/2,0][i%2] # http://yukicoder.me/problems/745 のおかげでこういう知見を得られたが,計算量を落とすには至りそうにない.
			#r+=x/i
			r+=n/i-(i-1)/2
		end
	}
	p r
end
__END__
[コードの説明]
たとえば18が3+4+5+6で表せるとした場合に、18 - (0+1+2+3) - 4*3=0と書ける。4は真ん中の和の項数を意味する。
よって、nをiで割った余りとi*(i-1)/2をiで割った余りが一致するかどうかでi個の数字の和で表せるかどうかを判定することができる。
なお、この余りは、iが奇数のときは0、偶数のときはi/2である。
また、18 - (3+4+5+6)=0と変形できることから、最初の式で4に掛けられている3はそのまま初項である。
項数はO(√n)なので、全探索しても時間制限には十分間に合う。
なお、iの上限は
(-1+Math.sqrt(1+8*n))/2 (inclusive)
または
(1+Math.sqrt(1+8*n))/2 (exclusive)
に固定でき、Math.sqrt(2*n) (exclusive)で近似することも可能であるが、いずれにせよsqrtの計算が必要なので、価値は低そうである。
[コメンタリー]
この答案は(EOF検出が困難なため入力部条件分岐も変更が必要な一部の言語を除き)、r+=x/iをr+=1に変更するだけで、
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2197
に提出することが可能となります。
つまり、この問題、既出でした。
幸い、(私はEasyしか解いていなかったので、Hardについては)ICPC JAG公式の解説を読む前にCodeIQ上で正解できたので良かったです。
ちなみに、多言語の答案を作ろうと思った最初の動機は、AOJのSolutionsに載せたかったからでした。