#!/usr/bin/ruby
#coding:utf-8
def 数字の割り当て方(a)
	den=(10-a.size+1..10).reduce(:*)
	num=1
	h=Hash.new(0)
	a.each{|e|num*=(h[e]+=1)}
	den/num
end
def 数字の並べ方(a)
	n=a.reduce(:+)
	r=1
	a.each{|e|
		e.times{|i|
			r=r*n/(i+1)
			n-=1
		}
	}
	r
end
def dfs(a,n,m)
	return to_enum(:dfs,a,n,m) if !block_given?
	return if a.size>10
	if n==0
		yield a[0]*数字の割り当て方(a)*数字の並べ方(a)
	else
		[m,n].min.downto(1){|i|
			dfs(a+[i],n-i,i){|e|yield e}
		}
	end
end
N=gets.to_i
R=1.step(N).reduce(0){|s,i|
	s+dfs([i],N-i,i).reduce(0,:+)
}/10
puts '%d.%0*d'%[R/10**(N-1),N-1,R%10**(N-1)]
__END__
【解答】
・第１問：2.01966
・第２問：3.10849098132
【方針】
まず、数字の並べ方を気にせず、多く出現するほど左に寄せた場合の組み合わせを列挙する。
N=6だと
[1, 1, 1, 1, 1, 1]
[2, 2, 2]
[2, 2, 1, 1]
[2, 1, 1, 1, 1]
[3, 3]
[3, 2, 1]
[3, 1, 1, 1]
[4, 2]
[4, 1, 1]
[5, 1]
[6]
といった具合である。
このそれぞれに対し、まず、0〜9の数字を割り当てる。その割り当て方は、分子が(10-配列長+1)〜10までの積(10P配列長)、分母が配列を同じ要素ごとに分けた場合のそれぞれの要素数の階乗の積となる。
例えば配列[2,2,1,1]の場合は(10P4) / (2!*2!)である。
次に、数字の並び方を考える。これは、例えば配列[2,2,1,1]の場合、6!/(2!2!1!1!)であり、いわば各要素が長さに相当するa.size次元の格子の移動の仕方である。
最終的に、配列の最初の要素(最も多く出現した数字の出現回数に等しい)、割り当て方、並べ方の積を取り、その和を10**Nで割ったものが解答となる。

ところで、数字の割り当て方と数字の並び方の計算時間は配列長に対し線形であるが、組み合わせの列挙については指数オーダーである。
しかし、Nが10増えるごとに個数が約10倍と、比較的ゆるやかであるため、N=60までなら現実的な時間で計算できそうである。

そういえば期待値が10越えるのがちょうどN=60なんですね。
(10.02122047413153283462793278061451568589234661797517861379920)

追記：return if a.size>10して良いのは自明。やってみたらN=60が10秒で解けるようになった。
【言語】
Ruby
【コード】