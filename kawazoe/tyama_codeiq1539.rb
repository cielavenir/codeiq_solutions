#!/usr/bin/ruby
#coding:utf-8

=begin
A=[0]
1.step(40){|i|
	A[i]=A[i-1]*2+2**(i-1)
}
=end

def f_(n)
	i=0
	i+=1 while 2**i<n
	bits=[]
	while n>0
		if 2**i<=n
			bits<<i
			n-=2**i
		end
		i-=1
	end
	# bits #=> [9, 8, 7, 6, 5, 3]
	#bits.map.with_index{|e,i|A[e]+1+(i*2**e)}.reduce(:+)

	# OEIS A001787
	bits.map.with_index{|e,i|1+((2*i+e)*2**~-e).to_i}.reduce(:+)
end

def f n
a=n.to_s(2).bytes
l=a.size
d=-1
r=0
a.map{|e|l-=1;e==49&&r+=1+(l+2*d+=1)*2**~-l}
r.to_i
end
p f 13
p f 255
p f 10**3
p f 10**10

__END__
【解答】
・第１問：4938
・第２問：164293127179
【方針】
まず、「0から2**n-1までを2進数で表した時の1の和」は、A[0]=0 および A[n]=A[n-1]*2+2**(n-1)で表される。
この状態で、ある数を2進数で表す時、i桁目が1ならば、((上位の1の数)*2**i)+A[i]+1を計算し、その和が答えとなる。
例えば、1000を2進数で表すと、1111101000となるので、
(0*2**9)+A[9]+1 + (1*2**8)+A[8]+1 + (2*2**7)+A[7]+1 + (3*2**6)+A[6]+1 + (4*2**5)+A[5]+1 + (5*2**3)+A[3]+1
と計算することができる。
【言語】
Ruby
【コード】