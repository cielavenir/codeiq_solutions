#!/usr/bin/ruby
N=gets.to_i
M=4
a=[1]+[0]*(M*N)
(1..N).each{|n|
	b=a.dup
	(1..M).each{|m|
		(M*n).downto(m){|i|b[i]+=a[i-m]}
	}
	(0..M*n).each{|i|
		a[i]=b[i]-a[i]
	}
}
r=0
9.step(N*M,9){|i|r+=a[i]}
p r
__END__
【コードの説明】
ある数が9の倍数であるには、(10進法表記で)各桁の和が9の倍数であれば良いという事実を用いる。

動的計画法を用いた。
配列aは、n桁使った時の各桁の和の個数を保持する。
配列bは、「n桁か(n+1)桁」使った時の各桁の和の個数になる。(後ろから舐める)
b-aにより、ちょうど(n+1)桁使った時について計算が可能になる。

N<=20なので、C++なら半分全列挙でも通るが、やはりO(N^2 M)の方がエレガントであろう。
【言語】
Ruby/C++